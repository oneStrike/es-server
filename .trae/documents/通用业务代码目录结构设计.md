# 通用业务代码目录结构设计

## 问题分析
当前项目中，`libs` 目录只包含与业务无关的通用代码（如 auth、cache、database 等），而业务代码则分散在各个应用（admin-api、client-api）中。当存在需要在多个应用间共享的通用业务代码时，当前结构无法很好地支持。

## 解决方案
基于现有项目架构和 NestJS 最佳实践，建议在 `libs` 目录下创建业务相关的库，用于存放通用业务代码。

## 具体设计

### 1. 目录结构设计
在 `libs` 目录下按业务领域创建子目录，每个子目录作为一个独立的业务库：

```
libs/
  ├── auth/              # 通用认证库（现有）
  ├── base/              # 通用基础库（现有）
  ├── cache/             # 通用缓存库（现有）
  ├── ...                # 其他现有通用库
  ├── work/              # 作品相关通用业务库
  │   ├── src/
  │   │   ├── dto/       # 数据传输对象
  │   │   ├── services/  # 业务服务
  │   │   ├── constants/ # 常量定义
  │   │   ├── decorators/ # 装饰器
  │   │   ├── index.ts   # 导出入口
  │   └── tsconfig.lib.json
  ├── user/              # 用户相关通用业务库
  │   ├── src/
  │   │   ├── dto/
  │   │   ├── services/
  │   │   ├── constants/
  │   │   ├── index.ts
  │   └── tsconfig.lib.json
  └── system/            # 系统相关通用业务库
      ├── src/
      │   ├── dto/
      │   ├── services/
      │   ├── constants/
      │   ├── index.ts
      └── tsconfig.lib.json
```

### 2. 模块结构设计
每个业务库遵循 NestJS 模块结构，包含：
- 业务服务（Services）
- 数据传输对象（DTOs）
- 常量定义
- 装饰器、拦截器等
- 导出入口（index.ts）

### 3. 依赖关系管理
- 业务库之间可以相互依赖，但需避免循环依赖
- 业务库可以依赖通用库（如 database、config 等）
- 应用（admin-api、client-api）可以依赖业务库

### 4. 配置更新
- 更新 `tsconfig.json` 中的路径映射，添加新业务库的映射
- 更新 `jest.config.js` 中的模块名映射
- 确保 `package.json` 中的依赖关系正确

## 实施步骤

1. **创建业务库目录结构**：在 `libs` 目录下创建业务相关的子目录
2. **配置 tsconfig.lib.json**：为每个业务库创建 TypeScript 配置文件
3. **更新路径映射**：修改 `tsconfig.json` 和 `jest.config.js`
4. **实现业务代码**：将通用业务代码迁移到对应的业务库中
5. **更新应用依赖**：修改应用代码，使用新创建的业务库
6. **测试验证**：确保所有应用能够正常构建和运行

## 预期效果
- 通用业务代码集中管理，提高复用性和可维护性
- 保持与现有架构的一致性
- 支持模块化开发，便于团队协作
- 符合 NestJS 最佳实践

## 示例：创建 work 业务库

```bash
# 创建目录结构
mkdir -p libs/work/src/{dto,services,constants}

# 创建 tsconfig.lib.json
cp libs/auth/tsconfig.lib.json libs/work/

# 更新 tsconfig.json 中的路径映射
# 更新 jest.config.js 中的模块名映射
```

## 注意事项
- 业务库应专注于通用业务逻辑，避免包含应用特定的代码
- 每个业务库应保持独立性，便于单独维护和测试
- 遵循现有项目的代码风格和命名规范
- 确保业务库的版本管理和发布流程

这个设计方案既保持了与现有项目结构的一致性，又解决了通用业务代码的组织问题，便于后续的扩展和维护。