# 审计日志解耦解决方案

## 问题分析
当前审计日志实现方式存在以下问题：
1. **强耦合**：业务代码直接依赖 `AuditService`，导致审计逻辑与业务逻辑混合
2. **重复代码**：每个业务操作都需要手动调用审计日志方法
3. **难以维护**：审计逻辑的修改会影响所有业务代码
4. **职责不清晰**：业务代码同时承担了业务逻辑和审计日志的职责

## 解决方案
基于 NestJS 框架特性，采用以下方案实现审计日志解耦：

### 1. 实现全局审计日志拦截器
- 创建 `AuditInterceptor` 拦截器，统一处理所有请求的审计日志
- 拦截器自动提取请求信息（IP、路径、方法等）
- 拦截器自动记录请求的成功/失败状态

### 2. 实现自定义审计装饰器
- 创建 `@Audit()` 装饰器，用于标记需要特殊处理的方法
- 装饰器支持自定义操作类型、内容模板等
- 装饰器可以应用于控制器方法或服务方法

### 3. 优化审计日志服务
- 保持 `AuditService` 负责实际的日志存储
- 移除业务代码中的直接调用
- 支持异步日志记录，提高系统性能

### 4. 实现步骤
1. 创建 `AuditInterceptor` 拦截器
2. 创建 `@Audit()` 自定义装饰器
3. 注册拦截器为全局拦截器
4. 移除业务代码中的直接审计日志调用
5. 测试验证解决方案

## 预期效果
1. **业务代码解耦**：业务代码不再需要关注审计日志逻辑
2. **统一管理**：审计日志逻辑集中在拦截器和装饰器中
3. **易于扩展**：新增审计需求只需修改拦截器或装饰器
4. **性能提升**：异步日志记录减少对业务流程的影响
5. **职责清晰**：业务代码专注于业务逻辑，审计逻辑专注于日志记录

## 技术实现要点
- 使用 NestJS 的 `Interceptor` 机制统一处理请求
- 使用 NestJS 的 `Custom Decorator` 机制标记需要审计的方法
- 使用 `Reflector` 从装饰器中获取元数据
- 支持异步日志记录，避免阻塞业务流程
- 保持与现有审计日志数据结构的兼容性

## 影响范围
- 需要修改所有直接调用 `AuditService` 的业务代码
- 需要新增拦截器和装饰器文件
- 需要更新模块配置，注册全局拦截器

## 风险评估
- 低风险：解决方案基于 NestJS 框架特性，技术成熟
- 易于回滚：如果出现问题，可以快速恢复到原有实现
- 兼容性好：保持与现有审计日志数据结构的兼容

## 测试策略
1. 单元测试：测试拦截器和装饰器的功能
2. 集成测试：测试拦截器与业务代码的集成
3. 端到端测试：测试完整的审计日志流程
4. 性能测试：验证异步日志记录对系统性能的影响