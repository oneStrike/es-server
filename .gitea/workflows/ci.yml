name: Build and Package

on:
  push:
    branches:
      - main
      - master
    tags:
      - 'v*.*.*'
  pull_request:
    branches:
      - main
      - master

jobs:
  docker-build:
    runs-on: es
    env:
      NODE_VERSION: '22'
      IMAGE_NAME: es-server
      # 修改为服务器上 docker-compose.yml 的实际绝对路径
      COMPOSE_FILE_PATH: /www/server/panel/data/compose/es/docker-compose.yml
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 清理使用旧镜像的容器（若存在）
        run: |
          set -e
          IMAGE_TAG="${{ env.IMAGE_NAME }}:latest"
          CONTAINERS=$(docker ps -a --filter "ancestor=${IMAGE_TAG}" -q || true)
          if [ -n "$CONTAINERS" ]; then
            echo "Found containers using ${IMAGE_TAG}. Removing them..."
            docker rm -f $CONTAINERS || true
          else
            echo "No containers are using ${IMAGE_TAG}."
          fi

      - name: 仅清理当前镜像的 latest 标签（若存在）
        run: |
          set -e
          IMAGE_TAG="${{ env.IMAGE_NAME }}:latest"
          IMAGE_ID=$(docker images -q "$IMAGE_TAG" || true)
          if [ -n "$IMAGE_ID" ]; then
            echo "Removing existing image $IMAGE_TAG..."
            # 先确保没有容器在使用（前一步已处理），再删除该标签
            docker rmi -f "$IMAGE_TAG" || true
          else
            echo "No existing $IMAGE_TAG found. Proceeding with normal build."
          fi

      - name: 打包镜像
        id: build_image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          tags: ${{ env.IMAGE_NAME }}:latest
          cache-from: type=local,src=/data/cache/server/buildx
          cache-to: type=local,dest=/data/cache/server/buildx,mode=max
          load: true

      - name: 使用最新镜像重启服务（Compose）
        run: |
          set -e
          COMPOSE_FILE="${{ env.COMPOSE_FILE_PATH }}"
          if [ ! -f "$COMPOSE_FILE" ]; then
            echo "未找到 Compose 文件: $COMPOSE_FILE"
            exit 1
          fi

          # 兼容 docker compose v2 和旧版 docker-compose
          if docker compose version >/dev/null 2>&1; then
            COMPOSE_CMD="docker compose"
          elif command -v docker-compose >/dev/null 2>&1; then
            COMPOSE_CMD="docker-compose"
          else
            echo "Docker Compose 未安装或不可用"
            exit 1
          fi

          # 使用最新镜像强制重建并启动服务
          $COMPOSE_CMD -f "$COMPOSE_FILE" up -d --force-recreate --remove-orphans

      - name: 构建后清理悬空镜像
        run: |
          # 清理构建过程中产生的悬空镜像，避免出现 <none> 标签占用空间
          docker image prune -f || true