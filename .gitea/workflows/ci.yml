name: Build and Package

on:
  push:
    branches:
      - main
      - master
    tags:
      - 'v*.*.*'
  pull_request:
    branches:
      - main
      - master

jobs:
  docker-build:
    runs-on: es
    env:
      NODE_VERSION: '22'
      IMAGE_NAME: es-server
      # 修改为服务器上 docker-compose.yml 的实际绝对路径
      COMPOSE_FILE_PATH: /www/server/panel/data/compose/es/docker-compose.yaml
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 为避免构建期间服务中断：不再提前删除旧容器/镜像
      # 直接构建新镜像，随后用 Compose 强制重建并拉起服务，最后进行清理。

      - name: 打包镜像
        id: build_image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          tags: ${{ env.IMAGE_NAME }}:latest
          cache-from: type=local,src=/data/cache/server/buildx
          cache-to: type=local,dest=/data/cache/server/buildx,mode=max
          load: true

      - name: 使用最新镜像重启服务（Compose）
        run: |
          set -e
          COMPOSE_FILE="${{ env.COMPOSE_FILE_PATH }}"
          if [ ! -f "$COMPOSE_FILE" ]; then
            echo "未找到 Compose 文件: $COMPOSE_FILE"
            exit 1
          fi

          # 兼容 docker compose v2 和旧版 docker-compose
          if docker compose version >/dev/null 2>&1; then
            COMPOSE_CMD="docker compose"
          elif command -v docker-compose >/dev/null 2>&1; then
            COMPOSE_CMD="docker-compose"
          else
            echo "Docker Compose 未安装或不可用"
            exit 1
          fi

          # 使用最新镜像强制重建并启动服务
          $COMPOSE_CMD -f "$COMPOSE_FILE" up -d --force-recreate --remove-orphans

      - name: 构建后清理悬空镜像
        run: |
          # 清理构建过程中产生的悬空镜像，避免出现 <none> 标签占用空间
          docker image prune -f || true