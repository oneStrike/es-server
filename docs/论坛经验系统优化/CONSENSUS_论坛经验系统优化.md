# CONSENSUS_论坛经验系统优化

## 一、明确的需求描述和验收标准

### 1.1 需求描述
将论坛系统的用户等级从基于积分改为基于经验值，实现积分和经验的分离：
- **积分**：可消费的虚拟货币，用于经济系统
- **经验**：只增不减的累积值，用于等级计算
- **等级**：基于经验值计算，与权限系统绑定

### 1.2 验收标准

#### 功能验收标准
- [ ] ForumProfile 表新增 experience 字段
- [ ] ForumLevelRule 表的 requiredPoints 改为 requiredExperience
- [ ] 新增 ForumExperienceRule 表
- [ ] 新增 ForumExperienceRecord 表
- [ ] ExperienceService 实现完整功能
- [ ] LevelRuleService 的等级升级逻辑改为基于经验
- [ ] 管理端 API 提供经验规则 CRUD
- [ ] 管理端 API 提供经验记录查询
- [ ] 客户端 API 提供用户经验信息查询
- [ ] 数据迁移脚本完成并测试通过
- [ ] 所有测试通过
- [ ] 代码符合项目规范

#### 性能验收标准
- [ ] 经验增加操作响应时间 < 100ms
- [ ] 等级升级检查操作响应时间 < 100ms
- [ ] 经验记录查询响应时间 < 200ms
- [ ] 数据库索引优化合理

#### 兼容性验收标准
- [ ] 现有积分系统功能不受影响
- [ ] 现有等级权限系统功能不受影响
- [ ] API 向后兼容（不删除现有接口）
- [ ] 数据迁移后用户等级保持不变

## 二、技术实现方案

### 2.1 技术栈
- **框架**: NestJS
- **ORM**: Prisma
- **数据库**: PostgreSQL
- **验证**: class-validator
- **文档**: @nestjs/swagger
- **测试**: Jest

### 2.2 核心技术方案

#### 2.2.1 数据模型设计
- 新增 `ForumExperienceRule` 表：存储经验获取规则
- 新增 `ForumExperienceRecord` 表：记录经验变化历史
- 修改 `ForumProfile` 表：新增 `experience` 字段
- 修改 `ForumLevelRule` 表：`requiredPoints` 改为 `requiredExperience`

#### 2.2.2 服务层设计
- 新增 `ExperienceService`：处理经验增加、规则管理、记录查询
- 修改 `LevelRuleService`：等级升级逻辑改为基于经验值

#### 2.2.3 API 层设计
- 管理端 API：经验规则 CRUD、经验记录查询、用户经验统计
- 客户端 API：用户经验信息查询

### 2.3 技术约束
- 遵循现有代码规范和架构模式
- 保持向后兼容性
- 使用事务确保数据一致性
- 完善的错误处理和日志记录

## 三、任务边界限制

### 3.1 包含范围
- 设计并实现经验值系统（数据库模型、服务层、API层）
- 修改等级升级逻辑，从基于积分改为基于经验
- 创建经验规则配置功能
- 创建经验记录功能
- 数据迁移方案（现有用户数据迁移）
- 更新相关文档

### 3.2 不包含范围
- 修改积分系统的现有功能（积分规则、积分记录等）
- 修改等级权限系统（保持现有权限配置不变）
- 前端界面调整（仅提供后端API）

## 四、集成方案

### 4.1 与现有系统集成

#### 4.1.1 与积分系统集成
- 经验系统和积分系统独立运行
- 经验规则和积分规则独立配置
- 用户行为可以同时获得积分和经验

#### 4.1.2 与等级系统集成
- 等级升级基于经验值而非积分
- 等级权限系统保持不变
- 等级规则配置保持不变（仅修改字段名）

#### 4.1.3 与用户系统集成
- 用户资料表新增经验字段
- 经验记录关联到用户资料
- 保持用户数据一致性

### 4.2 数据迁移方案
- 将现有用户的积分值作为初始经验值
- 保持用户等级不变
- 使用事务确保数据一致性
- 提供回滚方案

### 4.3 API 集成方案
- 管理端 API 新增经验管理接口
- 客户端 API 新增经验查询接口
- 保持现有 API 不变（向后兼容）

## 五、已确认的决策

### 5.1 核心设计决策
1. **采用方案一**：分离积分和经验系统
2. **经验值特性**：只增不减
3. **等级计算**：基于经验值，不基于积分
4. **数据迁移**：将现有积分作为初始经验值
5. **规则配置**：经验规则与积分规则独立配置
6. **经验上限**：无上限
7. **经验衰减**：不衰减

### 5.2 技术实现决策
1. **数据库设计**：新增两个表，修改两个表
2. **服务层设计**：新增 ExperienceService，修改 LevelRuleService
3. **API 设计**：管理端和客户端分别提供接口
4. **事务处理**：使用 Prisma 事务确保数据一致性
5. **错误处理**：完善的异常处理和日志记录
6. **性能优化**：合理使用索引和缓存

### 5.3 业务规则决策
1. **经验获取规则**：参考积分规则，但独立配置
2. **每日上限**：支持配置，防止刷经验
3. **等级升级**：自动触发，无需手动操作
4. **经验记录**：完整记录所有经验变化

## 六、确认所有不确定性已解决

### 6.1 已解决的问题

#### 6.1.1 数据迁移策略
**问题**：现有用户的积分如何转换为经验值？

**决策**：采用选项 A，将当前积分作为初始经验值，保持用户等级不变。

#### 6.1.2 经验规则与积分规则的关系
**问题**：经验规则是否需要与积分规则保持一致？

**决策**：采用选项 A，经验规则和积分规则独立配置，但提供默认值参考积分规则。

#### 6.1.3 等级计算方式
**问题**：等级计算是否需要考虑其他因素？

**决策**：采用选项 A，仅基于经验值计算等级，保持简单清晰。

#### 6.1.4 经验值是否需要上限
**问题**：经验值是否需要设置上限？

**决策**：采用选项 A，无上限，但可以设置最高等级。

#### 6.1.5 是否需要经验衰减机制
**问题**：是否需要经验值随时间衰减？

**决策**：采用选项 A，不衰减，保持用户友好。

### 6.2 已确认的技术细节
- 数据库表结构和字段定义
- 服务层方法和接口定义
- API 路由和参数定义
- DTO 类和验证规则
- 异常处理策略
- 性能优化方案
- 安全设计

### 6.3 已确认的业务规则
- 经验获取规则类型
- 每日上限机制
- 等级升级触发条件
- 经验记录保存规则

## 七、项目特性规范对齐

### 7.1 项目架构对齐
- 遵循 Monorepo 结构
- 使用模块化设计
- 保持与现有模块的一致性

### 7.2 代码规范对齐
- 使用 TypeScript
- 使用 class-validator 进行参数验证
- 使用 Swagger 生成 API 文档
- 使用装饰器模式
- DTO 继承模式

### 7.3 数据库规范对齐
- 使用 Prisma ORM
- 遵循 Prisma 模型命名规范
- 合理使用索引
- 完整的字段注释

### 7.4 API 规范对齐
- RESTful API 设计
- 统一的响应格式
- 完善的错误处理
- 清晰的 API 文档

## 八、质量标准

### 8.1 代码质量
- 代码规范：符合项目 ESLint 规则
- 可读性：代码清晰易懂，注释完整
- 复杂度：方法复杂度控制在合理范围
- 可维护性：代码结构清晰，易于维护

### 8.2 测试质量
- 覆盖率：单元测试覆盖率 > 80%
- 用例有效性：测试用例覆盖所有业务场景
- 边界条件：充分测试边界条件和异常情况

### 8.3 文档质量
- 完整性：文档覆盖所有功能点
- 准确性：文档与实现保持一致
- 一致性：文档风格统一

### 8.4 性能质量
- 响应时间：符合性能验收标准
- 并发处理：支持高并发访问
- 资源占用：内存和 CPU 占用合理

### 8.5 安全质量
- 权限控制：完善的权限验证
- 数据验证：严格的参数验证
- 防刷机制：有效的防刷措施

## 九、风险控制

### 9.1 技术风险
- **风险**：数据迁移可能导致数据不一致
- **应对**：编写详细的迁移脚本，进行充分测试，提供回滚方案

### 9.2 业务风险
- **风险**：用户对经验系统不理解
- **应对**：提供清晰的文档和说明

### 9.3 性能风险
- **风险**：经验记录表数据量大，影响查询性能
- **应对**：合理设计索引，考虑分表策略

### 9.4 兼容性风险
- **风险**：可能影响现有功能
- **应对**：保持向后兼容，充分测试

## 十、项目计划

### 10.1 任务分解
共 16 个原子任务，分为 6 个阶段：
1. 基础模型和常量（任务1-2）
2. DTO 定义（任务3-4）
3. 服务层实现（任务5-8）
4. 控制器和模块（任务6-7）
5. 模型修改和迁移（任务9-13）
6. 测试和部署（任务14-16）

### 10.2 执行顺序
按照任务依赖关系依次执行，确保每个任务的前置依赖都已满足。

### 10.3 质量门控
- 每个任务完成后进行代码检查
- 每个阶段完成后进行阶段性检查
- 最终验收确保所有标准满足

## 十一、成功标准

### 11.1 功能成功标准
- 所有功能按需求实现
- 所有测试通过
- 代码质量符合标准

### 11.2 性能成功标准
- 所有性能指标达标
- 系统运行稳定
- 资源占用合理

### 11.3 用户体验成功标准
- 用户等级保持不变
- 经验系统易于理解
- 系统响应及时

### 11.4 项目成功标准
- 项目按时交付
- 文档完整准确
- 团队满意
