# 账号登录失败锁定方案分析与对齐 (ALIGNMENT)

## 1. 项目上下文分析

### 1.1 现有架构
- **认证服务**: `AuthService` 处理登录逻辑。
- **数据存储**: PostgreSQL (`AppUser` 表) 存储用户信息。
- **缓存服务**: 项目已集成 Redis (`CACHE_MANAGER`)，用于 Token 存储和配置缓存。
- **当前逻辑**:
  - 用户提交账号/手机号 + 密码。
  - `AuthService.login` 验证用户是否存在。
  - `scryptService.verifyPassword` 验证密码。
  - 验证失败直接抛出 `BadRequestException`。
  - 无失败次数记录，无锁定机制。

### 1.2 数据模型 (`AppUser`)
- 包含 `status` 字段 (正常/禁言/封禁)，用于管理层面的封禁。
- **不包含** 登录失败计数或临时锁定字段。

## 2. 需求理解与确认

### 2.1 核心需求
- 当用户连续输入错误密码达到一定次数时，临时锁定该账号，防止暴力破解。

### 2.2 关键参数 (建议默认值)
- **最大失败次数**: 5 次
- **统计窗口**: 5 分钟 (即5分钟内连续错5次)
- **锁定时间**: 30 分钟

## 3. 技术方案建议

考虑到性能和对现有数据库架构的影响，**强烈建议使用 Redis 实现**，而非修改数据库表结构。

### 方案: 基于 Redis 的计数器与锁定

#### 逻辑流程
1. **登录请求**: 用户发起登录。
2. **检查锁定**: 
   - 检查 Redis Key `auth:lock:user:{userId}`。
   - 如存在，抛出异常："账号已锁定，请于 {解锁时间} 后重试"。
3. **验证密码**:
   - **成功**: 
     - 清除失败计数 Key `auth:fail:user:{userId}` (可选)。
     - 继续后续登录流程。
   - **失败**:
     - Redis 计数器 `auth:fail:user:{userId}` 加 1。
     - 设置计数器过期时间（如 5 分钟）。
     - **检查阈值**:
       - 如果计数 < 5: 抛出异常 "密码错误，还剩 {5-N} 次机会"。
       - 如果计数 >= 5: 
         - 设置锁定 Key `auth:lock:user:{userId}`，TTL 为 30 分钟。
         - 抛出异常 "密码错误次数过多，账号已锁定 30 分钟"。

#### 优点
- **无侵入**: 不需要修改 `AppUser` 表结构，无需数据库迁移。
- **高性能**: Redis 读写速度极快，不增加数据库负担。
- **自动过期**: 利用 Redis TTL 自动处理解锁，无需定时任务。

## 4. 待确认事项 (Consensus Needed)

请确认以下决策点：

1. **方案选择**: 是否同意使用 Redis 方案？(如需数据库持久化锁定，需修改 Schema)
2. **参数配置**: 
   - 阈值: 5 次?
   - 锁定时间: 30 分钟?
3. **提示信息**: 是否需要在密码错误提示中告知剩余次数？(安全与体验的权衡，建议提示)

---
*请确认以上方案，确认后将进入架构设计与开发阶段。*
