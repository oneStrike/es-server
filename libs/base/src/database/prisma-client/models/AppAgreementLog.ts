
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `AppAgreementLog` model and its related types.
 *
 * üü¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model AppAgreementLog
 * Â∫îÁî®ÂçèËÆÆÁ≠æÁΩ≤ËÆ∞ÂΩïË°®
 */
export type AppAgreementLogModel = runtime.Types.Result.DefaultSelection<Prisma.$AppAgreementLogPayload>

export type AggregateAppAgreementLog = {
  _count: AppAgreementLogCountAggregateOutputType | null
  _avg: AppAgreementLogAvgAggregateOutputType | null
  _sum: AppAgreementLogSumAggregateOutputType | null
  _min: AppAgreementLogMinAggregateOutputType | null
  _max: AppAgreementLogMaxAggregateOutputType | null
}

export type AppAgreementLogAvgAggregateOutputType = {
  id: number | null
  userId: number | null
  agreementId: number | null
}

export type AppAgreementLogSumAggregateOutputType = {
  id: bigint | null
  userId: number | null
  agreementId: number | null
}

export type AppAgreementLogMinAggregateOutputType = {
  id: bigint | null
  userId: number | null
  agreementId: number | null
  version: string | null
  agreedAt: Date | null
  ipAddress: string | null
  deviceInfo: string | null
}

export type AppAgreementLogMaxAggregateOutputType = {
  id: bigint | null
  userId: number | null
  agreementId: number | null
  version: string | null
  agreedAt: Date | null
  ipAddress: string | null
  deviceInfo: string | null
}

export type AppAgreementLogCountAggregateOutputType = {
  id: number
  userId: number
  agreementId: number
  version: number
  agreedAt: number
  ipAddress: number
  deviceInfo: number
  _all: number
}


export type AppAgreementLogAvgAggregateInputType = {
  id?: true
  userId?: true
  agreementId?: true
}

export type AppAgreementLogSumAggregateInputType = {
  id?: true
  userId?: true
  agreementId?: true
}

export type AppAgreementLogMinAggregateInputType = {
  id?: true
  userId?: true
  agreementId?: true
  version?: true
  agreedAt?: true
  ipAddress?: true
  deviceInfo?: true
}

export type AppAgreementLogMaxAggregateInputType = {
  id?: true
  userId?: true
  agreementId?: true
  version?: true
  agreedAt?: true
  ipAddress?: true
  deviceInfo?: true
}

export type AppAgreementLogCountAggregateInputType = {
  id?: true
  userId?: true
  agreementId?: true
  version?: true
  agreedAt?: true
  ipAddress?: true
  deviceInfo?: true
  _all?: true
}

export type AppAgreementLogAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which AppAgreementLog to aggregate.
   */
  where?: Prisma.AppAgreementLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of AppAgreementLogs to fetch.
   */
  orderBy?: Prisma.AppAgreementLogOrderByWithRelationInput | Prisma.AppAgreementLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.AppAgreementLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `¬±n` AppAgreementLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` AppAgreementLogs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned AppAgreementLogs
  **/
  _count?: true | AppAgreementLogCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: AppAgreementLogAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: AppAgreementLogSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: AppAgreementLogMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: AppAgreementLogMaxAggregateInputType
}

export type GetAppAgreementLogAggregateType<T extends AppAgreementLogAggregateArgs> = {
      [P in keyof T & keyof AggregateAppAgreementLog]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateAppAgreementLog[P]>
    : Prisma.GetScalarType<T[P], AggregateAppAgreementLog[P]>
}




export type AppAgreementLogGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.AppAgreementLogWhereInput
  orderBy?: Prisma.AppAgreementLogOrderByWithAggregationInput | Prisma.AppAgreementLogOrderByWithAggregationInput[]
  by: Prisma.AppAgreementLogScalarFieldEnum[] | Prisma.AppAgreementLogScalarFieldEnum
  having?: Prisma.AppAgreementLogScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: AppAgreementLogCountAggregateInputType | true
  _avg?: AppAgreementLogAvgAggregateInputType
  _sum?: AppAgreementLogSumAggregateInputType
  _min?: AppAgreementLogMinAggregateInputType
  _max?: AppAgreementLogMaxAggregateInputType
}

export type AppAgreementLogGroupByOutputType = {
  id: bigint
  userId: number
  agreementId: number
  version: string
  agreedAt: Date
  ipAddress: string | null
  deviceInfo: string | null
  _count: AppAgreementLogCountAggregateOutputType | null
  _avg: AppAgreementLogAvgAggregateOutputType | null
  _sum: AppAgreementLogSumAggregateOutputType | null
  _min: AppAgreementLogMinAggregateOutputType | null
  _max: AppAgreementLogMaxAggregateOutputType | null
}

type GetAppAgreementLogGroupByPayload<T extends AppAgreementLogGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<AppAgreementLogGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof AppAgreementLogGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], AppAgreementLogGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], AppAgreementLogGroupByOutputType[P]>
      }
    >
  >



export type AppAgreementLogWhereInput = {
  AND?: Prisma.AppAgreementLogWhereInput | Prisma.AppAgreementLogWhereInput[]
  OR?: Prisma.AppAgreementLogWhereInput[]
  NOT?: Prisma.AppAgreementLogWhereInput | Prisma.AppAgreementLogWhereInput[]
  id?: Prisma.BigIntFilter<"AppAgreementLog"> | bigint | number
  userId?: Prisma.IntFilter<"AppAgreementLog"> | number
  agreementId?: Prisma.IntFilter<"AppAgreementLog"> | number
  version?: Prisma.StringFilter<"AppAgreementLog"> | string
  agreedAt?: Prisma.DateTimeFilter<"AppAgreementLog"> | Date | string
  ipAddress?: Prisma.StringNullableFilter<"AppAgreementLog"> | string | null
  deviceInfo?: Prisma.StringNullableFilter<"AppAgreementLog"> | string | null
  agreement?: Prisma.XOR<Prisma.AppAgreementScalarRelationFilter, Prisma.AppAgreementWhereInput>
  user?: Prisma.XOR<Prisma.AppUserScalarRelationFilter, Prisma.AppUserWhereInput>
}

export type AppAgreementLogOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  agreementId?: Prisma.SortOrder
  version?: Prisma.SortOrder
  agreedAt?: Prisma.SortOrder
  ipAddress?: Prisma.SortOrderInput | Prisma.SortOrder
  deviceInfo?: Prisma.SortOrderInput | Prisma.SortOrder
  agreement?: Prisma.AppAgreementOrderByWithRelationInput
  user?: Prisma.AppUserOrderByWithRelationInput
}

export type AppAgreementLogWhereUniqueInput = Prisma.AtLeast<{
  id?: bigint | number
  AND?: Prisma.AppAgreementLogWhereInput | Prisma.AppAgreementLogWhereInput[]
  OR?: Prisma.AppAgreementLogWhereInput[]
  NOT?: Prisma.AppAgreementLogWhereInput | Prisma.AppAgreementLogWhereInput[]
  userId?: Prisma.IntFilter<"AppAgreementLog"> | number
  agreementId?: Prisma.IntFilter<"AppAgreementLog"> | number
  version?: Prisma.StringFilter<"AppAgreementLog"> | string
  agreedAt?: Prisma.DateTimeFilter<"AppAgreementLog"> | Date | string
  ipAddress?: Prisma.StringNullableFilter<"AppAgreementLog"> | string | null
  deviceInfo?: Prisma.StringNullableFilter<"AppAgreementLog"> | string | null
  agreement?: Prisma.XOR<Prisma.AppAgreementScalarRelationFilter, Prisma.AppAgreementWhereInput>
  user?: Prisma.XOR<Prisma.AppUserScalarRelationFilter, Prisma.AppUserWhereInput>
}, "id">

export type AppAgreementLogOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  agreementId?: Prisma.SortOrder
  version?: Prisma.SortOrder
  agreedAt?: Prisma.SortOrder
  ipAddress?: Prisma.SortOrderInput | Prisma.SortOrder
  deviceInfo?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.AppAgreementLogCountOrderByAggregateInput
  _avg?: Prisma.AppAgreementLogAvgOrderByAggregateInput
  _max?: Prisma.AppAgreementLogMaxOrderByAggregateInput
  _min?: Prisma.AppAgreementLogMinOrderByAggregateInput
  _sum?: Prisma.AppAgreementLogSumOrderByAggregateInput
}

export type AppAgreementLogScalarWhereWithAggregatesInput = {
  AND?: Prisma.AppAgreementLogScalarWhereWithAggregatesInput | Prisma.AppAgreementLogScalarWhereWithAggregatesInput[]
  OR?: Prisma.AppAgreementLogScalarWhereWithAggregatesInput[]
  NOT?: Prisma.AppAgreementLogScalarWhereWithAggregatesInput | Prisma.AppAgreementLogScalarWhereWithAggregatesInput[]
  id?: Prisma.BigIntWithAggregatesFilter<"AppAgreementLog"> | bigint | number
  userId?: Prisma.IntWithAggregatesFilter<"AppAgreementLog"> | number
  agreementId?: Prisma.IntWithAggregatesFilter<"AppAgreementLog"> | number
  version?: Prisma.StringWithAggregatesFilter<"AppAgreementLog"> | string
  agreedAt?: Prisma.DateTimeWithAggregatesFilter<"AppAgreementLog"> | Date | string
  ipAddress?: Prisma.StringNullableWithAggregatesFilter<"AppAgreementLog"> | string | null
  deviceInfo?: Prisma.StringNullableWithAggregatesFilter<"AppAgreementLog"> | string | null
}

export type AppAgreementLogCreateInput = {
  id?: bigint | number
  version: string
  agreedAt?: Date | string
  ipAddress?: string | null
  deviceInfo?: string | null
  agreement: Prisma.AppAgreementCreateNestedOneWithoutAgreementLogsInput
  user: Prisma.AppUserCreateNestedOneWithoutAgreementLogsInput
}

export type AppAgreementLogUncheckedCreateInput = {
  id?: bigint | number
  userId: number
  agreementId: number
  version: string
  agreedAt?: Date | string
  ipAddress?: string | null
  deviceInfo?: string | null
}

export type AppAgreementLogUpdateInput = {
  id?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  version?: Prisma.StringFieldUpdateOperationsInput | string
  agreedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  ipAddress?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  deviceInfo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  agreement?: Prisma.AppAgreementUpdateOneRequiredWithoutAgreementLogsNestedInput
  user?: Prisma.AppUserUpdateOneRequiredWithoutAgreementLogsNestedInput
}

export type AppAgreementLogUncheckedUpdateInput = {
  id?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  agreementId?: Prisma.IntFieldUpdateOperationsInput | number
  version?: Prisma.StringFieldUpdateOperationsInput | string
  agreedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  ipAddress?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  deviceInfo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type AppAgreementLogCreateManyInput = {
  id?: bigint | number
  userId: number
  agreementId: number
  version: string
  agreedAt?: Date | string
  ipAddress?: string | null
  deviceInfo?: string | null
}

export type AppAgreementLogUpdateManyMutationInput = {
  id?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  version?: Prisma.StringFieldUpdateOperationsInput | string
  agreedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  ipAddress?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  deviceInfo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type AppAgreementLogUncheckedUpdateManyInput = {
  id?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  agreementId?: Prisma.IntFieldUpdateOperationsInput | number
  version?: Prisma.StringFieldUpdateOperationsInput | string
  agreedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  ipAddress?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  deviceInfo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type AppAgreementLogListRelationFilter = {
  every?: Prisma.AppAgreementLogWhereInput
  some?: Prisma.AppAgreementLogWhereInput
  none?: Prisma.AppAgreementLogWhereInput
}

export type AppAgreementLogOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type AppAgreementLogCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  agreementId?: Prisma.SortOrder
  version?: Prisma.SortOrder
  agreedAt?: Prisma.SortOrder
  ipAddress?: Prisma.SortOrder
  deviceInfo?: Prisma.SortOrder
}

export type AppAgreementLogAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  agreementId?: Prisma.SortOrder
}

export type AppAgreementLogMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  agreementId?: Prisma.SortOrder
  version?: Prisma.SortOrder
  agreedAt?: Prisma.SortOrder
  ipAddress?: Prisma.SortOrder
  deviceInfo?: Prisma.SortOrder
}

export type AppAgreementLogMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  agreementId?: Prisma.SortOrder
  version?: Prisma.SortOrder
  agreedAt?: Prisma.SortOrder
  ipAddress?: Prisma.SortOrder
  deviceInfo?: Prisma.SortOrder
}

export type AppAgreementLogSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  agreementId?: Prisma.SortOrder
}

export type AppAgreementLogCreateNestedManyWithoutAgreementInput = {
  create?: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutAgreementInput, Prisma.AppAgreementLogUncheckedCreateWithoutAgreementInput> | Prisma.AppAgreementLogCreateWithoutAgreementInput[] | Prisma.AppAgreementLogUncheckedCreateWithoutAgreementInput[]
  connectOrCreate?: Prisma.AppAgreementLogCreateOrConnectWithoutAgreementInput | Prisma.AppAgreementLogCreateOrConnectWithoutAgreementInput[]
  createMany?: Prisma.AppAgreementLogCreateManyAgreementInputEnvelope
  connect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
}

export type AppAgreementLogUncheckedCreateNestedManyWithoutAgreementInput = {
  create?: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutAgreementInput, Prisma.AppAgreementLogUncheckedCreateWithoutAgreementInput> | Prisma.AppAgreementLogCreateWithoutAgreementInput[] | Prisma.AppAgreementLogUncheckedCreateWithoutAgreementInput[]
  connectOrCreate?: Prisma.AppAgreementLogCreateOrConnectWithoutAgreementInput | Prisma.AppAgreementLogCreateOrConnectWithoutAgreementInput[]
  createMany?: Prisma.AppAgreementLogCreateManyAgreementInputEnvelope
  connect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
}

export type AppAgreementLogUpdateManyWithoutAgreementNestedInput = {
  create?: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutAgreementInput, Prisma.AppAgreementLogUncheckedCreateWithoutAgreementInput> | Prisma.AppAgreementLogCreateWithoutAgreementInput[] | Prisma.AppAgreementLogUncheckedCreateWithoutAgreementInput[]
  connectOrCreate?: Prisma.AppAgreementLogCreateOrConnectWithoutAgreementInput | Prisma.AppAgreementLogCreateOrConnectWithoutAgreementInput[]
  upsert?: Prisma.AppAgreementLogUpsertWithWhereUniqueWithoutAgreementInput | Prisma.AppAgreementLogUpsertWithWhereUniqueWithoutAgreementInput[]
  createMany?: Prisma.AppAgreementLogCreateManyAgreementInputEnvelope
  set?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  disconnect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  delete?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  connect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  update?: Prisma.AppAgreementLogUpdateWithWhereUniqueWithoutAgreementInput | Prisma.AppAgreementLogUpdateWithWhereUniqueWithoutAgreementInput[]
  updateMany?: Prisma.AppAgreementLogUpdateManyWithWhereWithoutAgreementInput | Prisma.AppAgreementLogUpdateManyWithWhereWithoutAgreementInput[]
  deleteMany?: Prisma.AppAgreementLogScalarWhereInput | Prisma.AppAgreementLogScalarWhereInput[]
}

export type AppAgreementLogUncheckedUpdateManyWithoutAgreementNestedInput = {
  create?: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutAgreementInput, Prisma.AppAgreementLogUncheckedCreateWithoutAgreementInput> | Prisma.AppAgreementLogCreateWithoutAgreementInput[] | Prisma.AppAgreementLogUncheckedCreateWithoutAgreementInput[]
  connectOrCreate?: Prisma.AppAgreementLogCreateOrConnectWithoutAgreementInput | Prisma.AppAgreementLogCreateOrConnectWithoutAgreementInput[]
  upsert?: Prisma.AppAgreementLogUpsertWithWhereUniqueWithoutAgreementInput | Prisma.AppAgreementLogUpsertWithWhereUniqueWithoutAgreementInput[]
  createMany?: Prisma.AppAgreementLogCreateManyAgreementInputEnvelope
  set?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  disconnect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  delete?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  connect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  update?: Prisma.AppAgreementLogUpdateWithWhereUniqueWithoutAgreementInput | Prisma.AppAgreementLogUpdateWithWhereUniqueWithoutAgreementInput[]
  updateMany?: Prisma.AppAgreementLogUpdateManyWithWhereWithoutAgreementInput | Prisma.AppAgreementLogUpdateManyWithWhereWithoutAgreementInput[]
  deleteMany?: Prisma.AppAgreementLogScalarWhereInput | Prisma.AppAgreementLogScalarWhereInput[]
}

export type BigIntFieldUpdateOperationsInput = {
  set?: bigint | number
  increment?: bigint | number
  decrement?: bigint | number
  multiply?: bigint | number
  divide?: bigint | number
}

export type AppAgreementLogCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutUserInput, Prisma.AppAgreementLogUncheckedCreateWithoutUserInput> | Prisma.AppAgreementLogCreateWithoutUserInput[] | Prisma.AppAgreementLogUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.AppAgreementLogCreateOrConnectWithoutUserInput | Prisma.AppAgreementLogCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.AppAgreementLogCreateManyUserInputEnvelope
  connect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
}

export type AppAgreementLogUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutUserInput, Prisma.AppAgreementLogUncheckedCreateWithoutUserInput> | Prisma.AppAgreementLogCreateWithoutUserInput[] | Prisma.AppAgreementLogUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.AppAgreementLogCreateOrConnectWithoutUserInput | Prisma.AppAgreementLogCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.AppAgreementLogCreateManyUserInputEnvelope
  connect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
}

export type AppAgreementLogUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutUserInput, Prisma.AppAgreementLogUncheckedCreateWithoutUserInput> | Prisma.AppAgreementLogCreateWithoutUserInput[] | Prisma.AppAgreementLogUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.AppAgreementLogCreateOrConnectWithoutUserInput | Prisma.AppAgreementLogCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.AppAgreementLogUpsertWithWhereUniqueWithoutUserInput | Prisma.AppAgreementLogUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.AppAgreementLogCreateManyUserInputEnvelope
  set?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  disconnect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  delete?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  connect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  update?: Prisma.AppAgreementLogUpdateWithWhereUniqueWithoutUserInput | Prisma.AppAgreementLogUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.AppAgreementLogUpdateManyWithWhereWithoutUserInput | Prisma.AppAgreementLogUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.AppAgreementLogScalarWhereInput | Prisma.AppAgreementLogScalarWhereInput[]
}

export type AppAgreementLogUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutUserInput, Prisma.AppAgreementLogUncheckedCreateWithoutUserInput> | Prisma.AppAgreementLogCreateWithoutUserInput[] | Prisma.AppAgreementLogUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.AppAgreementLogCreateOrConnectWithoutUserInput | Prisma.AppAgreementLogCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.AppAgreementLogUpsertWithWhereUniqueWithoutUserInput | Prisma.AppAgreementLogUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.AppAgreementLogCreateManyUserInputEnvelope
  set?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  disconnect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  delete?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  connect?: Prisma.AppAgreementLogWhereUniqueInput | Prisma.AppAgreementLogWhereUniqueInput[]
  update?: Prisma.AppAgreementLogUpdateWithWhereUniqueWithoutUserInput | Prisma.AppAgreementLogUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.AppAgreementLogUpdateManyWithWhereWithoutUserInput | Prisma.AppAgreementLogUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.AppAgreementLogScalarWhereInput | Prisma.AppAgreementLogScalarWhereInput[]
}

export type AppAgreementLogCreateWithoutAgreementInput = {
  id?: bigint | number
  version: string
  agreedAt?: Date | string
  ipAddress?: string | null
  deviceInfo?: string | null
  user: Prisma.AppUserCreateNestedOneWithoutAgreementLogsInput
}

export type AppAgreementLogUncheckedCreateWithoutAgreementInput = {
  id?: bigint | number
  userId: number
  version: string
  agreedAt?: Date | string
  ipAddress?: string | null
  deviceInfo?: string | null
}

export type AppAgreementLogCreateOrConnectWithoutAgreementInput = {
  where: Prisma.AppAgreementLogWhereUniqueInput
  create: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutAgreementInput, Prisma.AppAgreementLogUncheckedCreateWithoutAgreementInput>
}

export type AppAgreementLogCreateManyAgreementInputEnvelope = {
  data: Prisma.AppAgreementLogCreateManyAgreementInput | Prisma.AppAgreementLogCreateManyAgreementInput[]
  skipDuplicates?: boolean
}

export type AppAgreementLogUpsertWithWhereUniqueWithoutAgreementInput = {
  where: Prisma.AppAgreementLogWhereUniqueInput
  update: Prisma.XOR<Prisma.AppAgreementLogUpdateWithoutAgreementInput, Prisma.AppAgreementLogUncheckedUpdateWithoutAgreementInput>
  create: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutAgreementInput, Prisma.AppAgreementLogUncheckedCreateWithoutAgreementInput>
}

export type AppAgreementLogUpdateWithWhereUniqueWithoutAgreementInput = {
  where: Prisma.AppAgreementLogWhereUniqueInput
  data: Prisma.XOR<Prisma.AppAgreementLogUpdateWithoutAgreementInput, Prisma.AppAgreementLogUncheckedUpdateWithoutAgreementInput>
}

export type AppAgreementLogUpdateManyWithWhereWithoutAgreementInput = {
  where: Prisma.AppAgreementLogScalarWhereInput
  data: Prisma.XOR<Prisma.AppAgreementLogUpdateManyMutationInput, Prisma.AppAgreementLogUncheckedUpdateManyWithoutAgreementInput>
}

export type AppAgreementLogScalarWhereInput = {
  AND?: Prisma.AppAgreementLogScalarWhereInput | Prisma.AppAgreementLogScalarWhereInput[]
  OR?: Prisma.AppAgreementLogScalarWhereInput[]
  NOT?: Prisma.AppAgreementLogScalarWhereInput | Prisma.AppAgreementLogScalarWhereInput[]
  id?: Prisma.BigIntFilter<"AppAgreementLog"> | bigint | number
  userId?: Prisma.IntFilter<"AppAgreementLog"> | number
  agreementId?: Prisma.IntFilter<"AppAgreementLog"> | number
  version?: Prisma.StringFilter<"AppAgreementLog"> | string
  agreedAt?: Prisma.DateTimeFilter<"AppAgreementLog"> | Date | string
  ipAddress?: Prisma.StringNullableFilter<"AppAgreementLog"> | string | null
  deviceInfo?: Prisma.StringNullableFilter<"AppAgreementLog"> | string | null
}

export type AppAgreementLogCreateWithoutUserInput = {
  id?: bigint | number
  version: string
  agreedAt?: Date | string
  ipAddress?: string | null
  deviceInfo?: string | null
  agreement: Prisma.AppAgreementCreateNestedOneWithoutAgreementLogsInput
}

export type AppAgreementLogUncheckedCreateWithoutUserInput = {
  id?: bigint | number
  agreementId: number
  version: string
  agreedAt?: Date | string
  ipAddress?: string | null
  deviceInfo?: string | null
}

export type AppAgreementLogCreateOrConnectWithoutUserInput = {
  where: Prisma.AppAgreementLogWhereUniqueInput
  create: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutUserInput, Prisma.AppAgreementLogUncheckedCreateWithoutUserInput>
}

export type AppAgreementLogCreateManyUserInputEnvelope = {
  data: Prisma.AppAgreementLogCreateManyUserInput | Prisma.AppAgreementLogCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type AppAgreementLogUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.AppAgreementLogWhereUniqueInput
  update: Prisma.XOR<Prisma.AppAgreementLogUpdateWithoutUserInput, Prisma.AppAgreementLogUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.AppAgreementLogCreateWithoutUserInput, Prisma.AppAgreementLogUncheckedCreateWithoutUserInput>
}

export type AppAgreementLogUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.AppAgreementLogWhereUniqueInput
  data: Prisma.XOR<Prisma.AppAgreementLogUpdateWithoutUserInput, Prisma.AppAgreementLogUncheckedUpdateWithoutUserInput>
}

export type AppAgreementLogUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.AppAgreementLogScalarWhereInput
  data: Prisma.XOR<Prisma.AppAgreementLogUpdateManyMutationInput, Prisma.AppAgreementLogUncheckedUpdateManyWithoutUserInput>
}

export type AppAgreementLogCreateManyAgreementInput = {
  id?: bigint | number
  userId: number
  version: string
  agreedAt?: Date | string
  ipAddress?: string | null
  deviceInfo?: string | null
}

export type AppAgreementLogUpdateWithoutAgreementInput = {
  id?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  version?: Prisma.StringFieldUpdateOperationsInput | string
  agreedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  ipAddress?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  deviceInfo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  user?: Prisma.AppUserUpdateOneRequiredWithoutAgreementLogsNestedInput
}

export type AppAgreementLogUncheckedUpdateWithoutAgreementInput = {
  id?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  version?: Prisma.StringFieldUpdateOperationsInput | string
  agreedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  ipAddress?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  deviceInfo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type AppAgreementLogUncheckedUpdateManyWithoutAgreementInput = {
  id?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  version?: Prisma.StringFieldUpdateOperationsInput | string
  agreedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  ipAddress?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  deviceInfo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type AppAgreementLogCreateManyUserInput = {
  id?: bigint | number
  agreementId: number
  version: string
  agreedAt?: Date | string
  ipAddress?: string | null
  deviceInfo?: string | null
}

export type AppAgreementLogUpdateWithoutUserInput = {
  id?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  version?: Prisma.StringFieldUpdateOperationsInput | string
  agreedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  ipAddress?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  deviceInfo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  agreement?: Prisma.AppAgreementUpdateOneRequiredWithoutAgreementLogsNestedInput
}

export type AppAgreementLogUncheckedUpdateWithoutUserInput = {
  id?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  agreementId?: Prisma.IntFieldUpdateOperationsInput | number
  version?: Prisma.StringFieldUpdateOperationsInput | string
  agreedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  ipAddress?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  deviceInfo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type AppAgreementLogUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  agreementId?: Prisma.IntFieldUpdateOperationsInput | number
  version?: Prisma.StringFieldUpdateOperationsInput | string
  agreedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  ipAddress?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  deviceInfo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}



export type AppAgreementLogSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  agreementId?: boolean
  version?: boolean
  agreedAt?: boolean
  ipAddress?: boolean
  deviceInfo?: boolean
  agreement?: boolean | Prisma.AppAgreementDefaultArgs<ExtArgs>
  user?: boolean | Prisma.AppUserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["appAgreementLog"]>

export type AppAgreementLogSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  agreementId?: boolean
  version?: boolean
  agreedAt?: boolean
  ipAddress?: boolean
  deviceInfo?: boolean
  agreement?: boolean | Prisma.AppAgreementDefaultArgs<ExtArgs>
  user?: boolean | Prisma.AppUserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["appAgreementLog"]>

export type AppAgreementLogSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  agreementId?: boolean
  version?: boolean
  agreedAt?: boolean
  ipAddress?: boolean
  deviceInfo?: boolean
  agreement?: boolean | Prisma.AppAgreementDefaultArgs<ExtArgs>
  user?: boolean | Prisma.AppUserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["appAgreementLog"]>

export type AppAgreementLogSelectScalar = {
  id?: boolean
  userId?: boolean
  agreementId?: boolean
  version?: boolean
  agreedAt?: boolean
  ipAddress?: boolean
  deviceInfo?: boolean
}

export type AppAgreementLogOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "agreementId" | "version" | "agreedAt" | "ipAddress" | "deviceInfo", ExtArgs["result"]["appAgreementLog"]>
export type AppAgreementLogInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  agreement?: boolean | Prisma.AppAgreementDefaultArgs<ExtArgs>
  user?: boolean | Prisma.AppUserDefaultArgs<ExtArgs>
}
export type AppAgreementLogIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  agreement?: boolean | Prisma.AppAgreementDefaultArgs<ExtArgs>
  user?: boolean | Prisma.AppUserDefaultArgs<ExtArgs>
}
export type AppAgreementLogIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  agreement?: boolean | Prisma.AppAgreementDefaultArgs<ExtArgs>
  user?: boolean | Prisma.AppUserDefaultArgs<ExtArgs>
}

export type $AppAgreementLogPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "AppAgreementLog"
  objects: {
    /**
     * ÂÖ≥ËÅîÂçèËÆÆ
     */
    agreement: Prisma.$AppAgreementPayload<ExtArgs>
    /**
     * ÂÖ≥ËÅîÁî®Êà∑
     */
    user: Prisma.$AppUserPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    /**
     * ‰∏ªÈîÆID (‰ΩøÁî®BigIntÈò≤Ê≠¢ËÆ∞ÂΩïËøáÂ§ö)
     */
    id: bigint
    /**
     * Áî®Êà∑ID
     */
    userId: number
    /**
     * ÂçèËÆÆID
     */
    agreementId: number
    /**
     * Á≠æÁΩ≤Êó∂ÁöÑÂçèËÆÆÁâàÊú¨Âø´ÁÖß
     */
    version: string
    /**
     * Á≠æÁΩ≤Êó∂Èó¥
     */
    agreedAt: Date
    /**
     * Á≠æÁΩ≤IP
     */
    ipAddress: string | null
    /**
     * ËÆæÂ§á‰ø°ÊÅØ/UserAgent
     */
    deviceInfo: string | null
  }, ExtArgs["result"]["appAgreementLog"]>
  composites: {}
}

export type AppAgreementLogGetPayload<S extends boolean | null | undefined | AppAgreementLogDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload, S>

export type AppAgreementLogCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<AppAgreementLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
    select?: AppAgreementLogCountAggregateInputType | true
  }

export interface AppAgreementLogDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppAgreementLog'], meta: { name: 'AppAgreementLog' } }
  /**
   * Find zero or one AppAgreementLog that matches the filter.
   * @param {AppAgreementLogFindUniqueArgs} args - Arguments to find a AppAgreementLog
   * @example
   * // Get one AppAgreementLog
   * const appAgreementLog = await prisma.appAgreementLog.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends AppAgreementLogFindUniqueArgs>(args: Prisma.SelectSubset<T, AppAgreementLogFindUniqueArgs<ExtArgs>>): Prisma.Prisma__AppAgreementLogClient<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one AppAgreementLog that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {AppAgreementLogFindUniqueOrThrowArgs} args - Arguments to find a AppAgreementLog
   * @example
   * // Get one AppAgreementLog
   * const appAgreementLog = await prisma.appAgreementLog.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends AppAgreementLogFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, AppAgreementLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__AppAgreementLogClient<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first AppAgreementLog that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AppAgreementLogFindFirstArgs} args - Arguments to find a AppAgreementLog
   * @example
   * // Get one AppAgreementLog
   * const appAgreementLog = await prisma.appAgreementLog.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends AppAgreementLogFindFirstArgs>(args?: Prisma.SelectSubset<T, AppAgreementLogFindFirstArgs<ExtArgs>>): Prisma.Prisma__AppAgreementLogClient<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first AppAgreementLog that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AppAgreementLogFindFirstOrThrowArgs} args - Arguments to find a AppAgreementLog
   * @example
   * // Get one AppAgreementLog
   * const appAgreementLog = await prisma.appAgreementLog.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends AppAgreementLogFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, AppAgreementLogFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__AppAgreementLogClient<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more AppAgreementLogs that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AppAgreementLogFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all AppAgreementLogs
   * const appAgreementLogs = await prisma.appAgreementLog.findMany()
   * 
   * // Get first 10 AppAgreementLogs
   * const appAgreementLogs = await prisma.appAgreementLog.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const appAgreementLogWithIdOnly = await prisma.appAgreementLog.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends AppAgreementLogFindManyArgs>(args?: Prisma.SelectSubset<T, AppAgreementLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a AppAgreementLog.
   * @param {AppAgreementLogCreateArgs} args - Arguments to create a AppAgreementLog.
   * @example
   * // Create one AppAgreementLog
   * const AppAgreementLog = await prisma.appAgreementLog.create({
   *   data: {
   *     // ... data to create a AppAgreementLog
   *   }
   * })
   * 
   */
  create<T extends AppAgreementLogCreateArgs>(args: Prisma.SelectSubset<T, AppAgreementLogCreateArgs<ExtArgs>>): Prisma.Prisma__AppAgreementLogClient<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many AppAgreementLogs.
   * @param {AppAgreementLogCreateManyArgs} args - Arguments to create many AppAgreementLogs.
   * @example
   * // Create many AppAgreementLogs
   * const appAgreementLog = await prisma.appAgreementLog.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends AppAgreementLogCreateManyArgs>(args?: Prisma.SelectSubset<T, AppAgreementLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many AppAgreementLogs and returns the data saved in the database.
   * @param {AppAgreementLogCreateManyAndReturnArgs} args - Arguments to create many AppAgreementLogs.
   * @example
   * // Create many AppAgreementLogs
   * const appAgreementLog = await prisma.appAgreementLog.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many AppAgreementLogs and only return the `id`
   * const appAgreementLogWithIdOnly = await prisma.appAgreementLog.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends AppAgreementLogCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, AppAgreementLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a AppAgreementLog.
   * @param {AppAgreementLogDeleteArgs} args - Arguments to delete one AppAgreementLog.
   * @example
   * // Delete one AppAgreementLog
   * const AppAgreementLog = await prisma.appAgreementLog.delete({
   *   where: {
   *     // ... filter to delete one AppAgreementLog
   *   }
   * })
   * 
   */
  delete<T extends AppAgreementLogDeleteArgs>(args: Prisma.SelectSubset<T, AppAgreementLogDeleteArgs<ExtArgs>>): Prisma.Prisma__AppAgreementLogClient<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one AppAgreementLog.
   * @param {AppAgreementLogUpdateArgs} args - Arguments to update one AppAgreementLog.
   * @example
   * // Update one AppAgreementLog
   * const appAgreementLog = await prisma.appAgreementLog.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends AppAgreementLogUpdateArgs>(args: Prisma.SelectSubset<T, AppAgreementLogUpdateArgs<ExtArgs>>): Prisma.Prisma__AppAgreementLogClient<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more AppAgreementLogs.
   * @param {AppAgreementLogDeleteManyArgs} args - Arguments to filter AppAgreementLogs to delete.
   * @example
   * // Delete a few AppAgreementLogs
   * const { count } = await prisma.appAgreementLog.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends AppAgreementLogDeleteManyArgs>(args?: Prisma.SelectSubset<T, AppAgreementLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more AppAgreementLogs.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AppAgreementLogUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many AppAgreementLogs
   * const appAgreementLog = await prisma.appAgreementLog.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends AppAgreementLogUpdateManyArgs>(args: Prisma.SelectSubset<T, AppAgreementLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more AppAgreementLogs and returns the data updated in the database.
   * @param {AppAgreementLogUpdateManyAndReturnArgs} args - Arguments to update many AppAgreementLogs.
   * @example
   * // Update many AppAgreementLogs
   * const appAgreementLog = await prisma.appAgreementLog.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more AppAgreementLogs and only return the `id`
   * const appAgreementLogWithIdOnly = await prisma.appAgreementLog.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends AppAgreementLogUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, AppAgreementLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one AppAgreementLog.
   * @param {AppAgreementLogUpsertArgs} args - Arguments to update or create a AppAgreementLog.
   * @example
   * // Update or create a AppAgreementLog
   * const appAgreementLog = await prisma.appAgreementLog.upsert({
   *   create: {
   *     // ... data to create a AppAgreementLog
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the AppAgreementLog we want to update
   *   }
   * })
   */
  upsert<T extends AppAgreementLogUpsertArgs>(args: Prisma.SelectSubset<T, AppAgreementLogUpsertArgs<ExtArgs>>): Prisma.Prisma__AppAgreementLogClient<runtime.Types.Result.GetResult<Prisma.$AppAgreementLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of AppAgreementLogs.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AppAgreementLogCountArgs} args - Arguments to filter AppAgreementLogs to count.
   * @example
   * // Count the number of AppAgreementLogs
   * const count = await prisma.appAgreementLog.count({
   *   where: {
   *     // ... the filter for the AppAgreementLogs we want to count
   *   }
   * })
  **/
  count<T extends AppAgreementLogCountArgs>(
    args?: Prisma.Subset<T, AppAgreementLogCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], AppAgreementLogCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a AppAgreementLog.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AppAgreementLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends AppAgreementLogAggregateArgs>(args: Prisma.Subset<T, AppAgreementLogAggregateArgs>): Prisma.PrismaPromise<GetAppAgreementLogAggregateType<T>>

  /**
   * Group by AppAgreementLog.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AppAgreementLogGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends AppAgreementLogGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: AppAgreementLogGroupByArgs['orderBy'] }
      : { orderBy?: AppAgreementLogGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, AppAgreementLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppAgreementLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the AppAgreementLog model
 */
readonly fields: AppAgreementLogFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for AppAgreementLog.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__AppAgreementLogClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  agreement<T extends Prisma.AppAgreementDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.AppAgreementDefaultArgs<ExtArgs>>): Prisma.Prisma__AppAgreementClient<runtime.Types.Result.GetResult<Prisma.$AppAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  user<T extends Prisma.AppUserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.AppUserDefaultArgs<ExtArgs>>): Prisma.Prisma__AppUserClient<runtime.Types.Result.GetResult<Prisma.$AppUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the AppAgreementLog model
 */
export interface AppAgreementLogFieldRefs {
  readonly id: Prisma.FieldRef<"AppAgreementLog", 'BigInt'>
  readonly userId: Prisma.FieldRef<"AppAgreementLog", 'Int'>
  readonly agreementId: Prisma.FieldRef<"AppAgreementLog", 'Int'>
  readonly version: Prisma.FieldRef<"AppAgreementLog", 'String'>
  readonly agreedAt: Prisma.FieldRef<"AppAgreementLog", 'DateTime'>
  readonly ipAddress: Prisma.FieldRef<"AppAgreementLog", 'String'>
  readonly deviceInfo: Prisma.FieldRef<"AppAgreementLog", 'String'>
}
    

// Custom InputTypes
/**
 * AppAgreementLog findUnique
 */
export type AppAgreementLogFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogInclude<ExtArgs> | null
  /**
   * Filter, which AppAgreementLog to fetch.
   */
  where: Prisma.AppAgreementLogWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * AppAgreementLog findUniqueOrThrow
 */
export type AppAgreementLogFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogInclude<ExtArgs> | null
  /**
   * Filter, which AppAgreementLog to fetch.
   */
  where: Prisma.AppAgreementLogWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * AppAgreementLog findFirst
 */
export type AppAgreementLogFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogInclude<ExtArgs> | null
  /**
   * Filter, which AppAgreementLog to fetch.
   */
  where?: Prisma.AppAgreementLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of AppAgreementLogs to fetch.
   */
  orderBy?: Prisma.AppAgreementLogOrderByWithRelationInput | Prisma.AppAgreementLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for AppAgreementLogs.
   */
  cursor?: Prisma.AppAgreementLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `¬±n` AppAgreementLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` AppAgreementLogs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of AppAgreementLogs.
   */
  distinct?: Prisma.AppAgreementLogScalarFieldEnum | Prisma.AppAgreementLogScalarFieldEnum[]
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * AppAgreementLog findFirstOrThrow
 */
export type AppAgreementLogFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogInclude<ExtArgs> | null
  /**
   * Filter, which AppAgreementLog to fetch.
   */
  where?: Prisma.AppAgreementLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of AppAgreementLogs to fetch.
   */
  orderBy?: Prisma.AppAgreementLogOrderByWithRelationInput | Prisma.AppAgreementLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for AppAgreementLogs.
   */
  cursor?: Prisma.AppAgreementLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `¬±n` AppAgreementLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` AppAgreementLogs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of AppAgreementLogs.
   */
  distinct?: Prisma.AppAgreementLogScalarFieldEnum | Prisma.AppAgreementLogScalarFieldEnum[]
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * AppAgreementLog findMany
 */
export type AppAgreementLogFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogInclude<ExtArgs> | null
  /**
   * Filter, which AppAgreementLogs to fetch.
   */
  where?: Prisma.AppAgreementLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of AppAgreementLogs to fetch.
   */
  orderBy?: Prisma.AppAgreementLogOrderByWithRelationInput | Prisma.AppAgreementLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing AppAgreementLogs.
   */
  cursor?: Prisma.AppAgreementLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `¬±n` AppAgreementLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` AppAgreementLogs.
   */
  skip?: number
  distinct?: Prisma.AppAgreementLogScalarFieldEnum | Prisma.AppAgreementLogScalarFieldEnum[]
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * AppAgreementLog create
 */
export type AppAgreementLogCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogInclude<ExtArgs> | null
  /**
   * The data needed to create a AppAgreementLog.
   */
  data: Prisma.XOR<Prisma.AppAgreementLogCreateInput, Prisma.AppAgreementLogUncheckedCreateInput>
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * AppAgreementLog createMany
 */
export type AppAgreementLogCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many AppAgreementLogs.
   */
  data: Prisma.AppAgreementLogCreateManyInput | Prisma.AppAgreementLogCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * AppAgreementLog createManyAndReturn
 */
export type AppAgreementLogCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * The data used to create many AppAgreementLogs.
   */
  data: Prisma.AppAgreementLogCreateManyInput | Prisma.AppAgreementLogCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * AppAgreementLog update
 */
export type AppAgreementLogUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogInclude<ExtArgs> | null
  /**
   * The data needed to update a AppAgreementLog.
   */
  data: Prisma.XOR<Prisma.AppAgreementLogUpdateInput, Prisma.AppAgreementLogUncheckedUpdateInput>
  /**
   * Choose, which AppAgreementLog to update.
   */
  where: Prisma.AppAgreementLogWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * AppAgreementLog updateMany
 */
export type AppAgreementLogUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update AppAgreementLogs.
   */
  data: Prisma.XOR<Prisma.AppAgreementLogUpdateManyMutationInput, Prisma.AppAgreementLogUncheckedUpdateManyInput>
  /**
   * Filter which AppAgreementLogs to update
   */
  where?: Prisma.AppAgreementLogWhereInput
  /**
   * Limit how many AppAgreementLogs to update.
   */
  limit?: number
}

/**
 * AppAgreementLog updateManyAndReturn
 */
export type AppAgreementLogUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * The data used to update AppAgreementLogs.
   */
  data: Prisma.XOR<Prisma.AppAgreementLogUpdateManyMutationInput, Prisma.AppAgreementLogUncheckedUpdateManyInput>
  /**
   * Filter which AppAgreementLogs to update
   */
  where?: Prisma.AppAgreementLogWhereInput
  /**
   * Limit how many AppAgreementLogs to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * AppAgreementLog upsert
 */
export type AppAgreementLogUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogInclude<ExtArgs> | null
  /**
   * The filter to search for the AppAgreementLog to update in case it exists.
   */
  where: Prisma.AppAgreementLogWhereUniqueInput
  /**
   * In case the AppAgreementLog found by the `where` argument doesn't exist, create a new AppAgreementLog with this data.
   */
  create: Prisma.XOR<Prisma.AppAgreementLogCreateInput, Prisma.AppAgreementLogUncheckedCreateInput>
  /**
   * In case the AppAgreementLog was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.AppAgreementLogUpdateInput, Prisma.AppAgreementLogUncheckedUpdateInput>
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * AppAgreementLog delete
 */
export type AppAgreementLogDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogInclude<ExtArgs> | null
  /**
   * Filter which AppAgreementLog to delete.
   */
  where: Prisma.AppAgreementLogWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * AppAgreementLog deleteMany
 */
export type AppAgreementLogDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which AppAgreementLogs to delete
   */
  where?: Prisma.AppAgreementLogWhereInput
  /**
   * Limit how many AppAgreementLogs to delete.
   */
  limit?: number
}

/**
 * AppAgreementLog without action
 */
export type AppAgreementLogDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AppAgreementLog
   */
  select?: Prisma.AppAgreementLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AppAgreementLog
   */
  omit?: Prisma.AppAgreementLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AppAgreementLogInclude<ExtArgs> | null
}
